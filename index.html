
<head>
	<!-- Global site tag (gtag.js) - Google Analytics -->
	<script async src="https://www.googletagmanager.com/gtag/js?id=G-68J35F2R6N"></script>
	<script>
		window.dataLayer = window.dataLayer || [];

		function gtag() {
			dataLayer.push(arguments);
		}
		gtag('js', new Date());

		gtag('config', 'G-68J35F2R6N');
	</script>

	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Da Vinci Machine | ArjhanToteck</title>
	<link href="/style.css" rel="stylesheet" type="text/css" media="all">
	<link rel="icon" href="/favicon.png">
</head>

<h1 class="glitch" data-text="Da Vinci Machine">Da Vinci Machine</h1>

<div id="imageInputMenu">

	Click here or drag an image file here to begin: <input id="imageInput" type="file" accept="image/*">

	<br>
	<br>

	<button onclick="submitImage()">Next</button>

</div>

<div id="gridMenu" style="display:none">

	Rows: <input id="rowsInput" onchange="renderGrid()" type="number" style="width: 5em" value="100" />

	<br>
	<br>

	Columns:<input id="columnsInput" onchange="renderGrid()" type="number" style="width: 5em" value="100" />

	<br>
	<br>

	<button onclick="submitGrid()">Next</button>

	<br>
	<br>
</div>

<div id="lineDensityMenu" style="display:none">

	Minimum line density: <input id="minLineDensityInput" onchange="generateLines()" type="number" style="width: 5em" value="0" />

	<br>
	<br>

	Maximum line density: <input id="maxLineDensityInput" onchange="generateLines()" type="number" style="width: 5em" value="8" />

	<br>
	<br>

	Horizontal lines: <input id="horizontalLinesInput" onchange="generateLines()" type="checkbox" checked />

	<br>
	<br>

	Vertical lines: <input id="verticalLinesInput" onchange="generateLines()" type="checkbox" checked />

	<br>
	<br>

	<button onclick="submitLines()">Next</button>

	<br>
	<br>
</div>

<div id="physicalSettingsMenu" style="display:none">
	TODO: put physical settings here and then generate and download gcode
</div>

<canvas id="canvas" style="display:none;"></canvas>

<script>
	// TODO: add a way to go back through menus

	const imageInputMenu = document.getElementById("imageInputMenu");
	const imageInput = document.getElementById("imageInput");

	const gridMenu = document.getElementById("gridMenu");
	const rowsInput = document.getElementById("rowsInput");
	const columnsInput = document.getElementById("columnsInput");

	const lineDensityMenu = document.getElementById("lineDensityMenu");
	const minLineDensityInput = document.getElementById("minLineDensityInput");
	const maxLineDensityInput = document.getElementById("maxLineDensityInput");
	const horizontalLinesInput = document.getElementById("horizontalLinesInput");
	const verticalLinesInput = document.getElementById("verticalLinesInput");

	const physicalSettingsMenu = document.getElementById("physicalSettingsMenu");

	const canvas = document.getElementById("canvas");
	const context = canvas.getContext("2d");

	let image = new Image();
	let verticalLinesData = [];
	let horizontalLinesData = [];
	let combinedLinesData = [];

	imageInput.addEventListener('change', function (event) {
		// load image
		image.src = URL.createObjectURL(event.target.files[0]);
	});

	function submitImage() {
		// hide and display menus
		imageInputMenu.style.display = "none";
		gridMenu.style.display = "block";
		canvas.style.display = "block";

		renderGrid();
	}

	function renderGrid() {
		// set canvas dimensions
		canvas.width = image.width;
		canvas.height = image.height;

		// draw image on canvas
		context.drawImage(image, 0, 0, image.width, image.height);

		// draw grid
		rows = parseInt(rowsInput.value, 10);
		cellHeight = image.height / rows;

		columns = parseInt(columnsInput.value, 10);
		cellWidth = image.width / columns;

		// draw rows
		for (let i = 0; i < rows; i++) {
			// draw dashed line
			context.beginPath();
			context.moveTo(0, i * cellHeight);
			context.lineTo(image.width, i * cellHeight);
			context.strokeStyle = "#fc03f4";
			context.stroke();
		}

		// draw columns
		for (let i = 0; i < rows; i++) {
			// draw dashed line
			context.beginPath();
			context.moveTo(i * cellWidth, 0);
			context.lineTo(i * cellWidth, image.height);
			context.strokeStyle = "#fc03f4";
			context.stroke();
		}
	}

	function submitGrid() {
		// hide and display menus
		gridMenu.style.display = "none";
		lineDensityMenu.style.display = "block";

		generateLines();
	}

	function generateLines() {
		// clear line data
		verticalLinesData = [];
		horizontalLinesData = [];
		combinedLinesData = [];

		// draw image on canvas for processing
		context.drawImage(image, 0, 0, image.width, image.height);

		maxLineDensity = parseInt(maxLineDensityInput.value, 10);
		minLineDensity = parseInt(minLineDensityInput.value, 10);

		// get grid info
		rows = parseInt(rowsInput.value, 10);
		cellHeight = image.height / rows;

		columns = parseInt(columnsInput.value, 10);
		cellWidth = image.width / columns;

		// brightness variables
		cellBrigthnesses = [];
		brightestValue = 1;
		darkestValue = 0;

		// loop through every grid cell
		for (let y = 0; y < rows; y++) {
			cellBrigthnesses.push([])

			for (let x = 0; x < columns; x++) {
				// get cell image data
				let imageData = context.getImageData(x * cellWidth, y * cellHeight, cellWidth, cellHeight).data;

				// calculate average cell brightness
				let cellBrightness = 0;

				for (let i = 0; i < imageData.length; i += 4) {
					// RGB at i, i+1, and i+2
					let pixelBrightness = (imageData[i] + imageData[i + 1] + imageData[i + 2]) / 3;
					cellBrightness += pixelBrightness;
				}

				// get average for cell (divide by number of pixels in cell)
				cellBrightness /= imageData.length;

				// scale brightness from 0-1
				cellBrightness /= 255;

				// flip scale (lightest is 0, darkest is 1)
				cellBrightness = 1 - cellBrightness;

				// check if brightest value
				if (cellBrightness < brightestValue) {
					brightestValue = cellBrightness;
				}

				// check if darkest value
				if (cellBrightness > darkestValue) {
					darkestValue = cellBrightness;
				}

				cellBrigthnesses[y].push(cellBrightness);
			}
		}

		// clear canvas for drawing
		context.clearRect(0, 0, canvas.width, canvas.height);
		context.strokeStyle = "#000000";

		// draw cells
		for (let y = 0; y < rows; y++) {
			
			// create empty array for row in linesData arrays
			horizontalLinesData.push([]);
			verticalLinesData.push([]);

			for (let x = 0; x < columns; x++) {
				// scale brightness by factors of brightest and darkest values

				// check for all values being the same
				if (darkestValue == brightestValue) {
					cellBrigthnesses[y][x] = 0.5;
				} else {
					// scale to a number of lines
					cellBrigthnesses[y][x] = (cellBrigthnesses[y][x] - brightestValue) / (darkestValue - brightestValue);
				}

				// translate brightness to number of lines
				cellLineCount = Math.round((cellBrigthnesses[y][x] * (maxLineDensity - minLineDensity)) + minLineDensity);

				// draw lines in cell

				// calculate line distance
				let lineDistance = cellWidth / cellLineCount;
				
				// create empty array for cell in linesData arrays
				horizontalLinesData[y].push([]);
				verticalLinesData[y].push([]);

				// loop through lines
				for (let i = 0; i < cellLineCount; i++) {
					// draw lines
					
					// horizontal
					if (horizontalLinesInput.checked) {
						// create line
						startPoint = [x * cellWidth, (i * lineDistance) + (y * cellHeight)];
						endPoint = [(x * cellWidth) + cellWidth, (i * lineDistance) + (y * cellHeight)];
						line = new Line(startPoint, endPoint, Line.directions.horizontal);
						horizontalLinesData[y][x].push(line);
						

						// draw line
						context.beginPath();
						context.moveTo(...startPoint);
						context.lineTo(...endPoint);
						context.stroke();
					}

					// vertical
					if (verticalLinesInput.checked) {
						// create line
						startPoint = [(i * lineDistance) + (x * cellWidth), y * cellHeight];
						endPoint = [(i * lineDistance) + (x * cellWidth), (y * cellHeight) + cellHeight];
						line = new Line(startPoint, endPoint, Line.directions.vertical);
						verticalLinesData[y][x].push(line);

						// draw line
						context.beginPath();
						context.moveTo(...startPoint);
						context.lineTo(...endPoint);
						context.stroke();
					}
				}
			}
		}
	}

	// line constructor
	function Line(startPoint, endPoint, direction, combinationsChecked = false){
		this.startPoint = startPoint;
		this.endPoint = endPoint;
		this.direction = direction;
		this.combinationsChecked = combinationsChecked;
	}

	// static directions enum
	Line.directions = {
		horizontal: 0,
		vertical: 1
	};

	
	function submitLines() {
		// hide and display menus
		lineDensityMenu.style.display = "none";
		physicalSettingsMenu.style.display = "block";

		// right now, there are a bunch of redundant lines, we need to combine them
		combineLines();
	}

	function combineLines() {
		// clear combined lines data
		combinedLinesData = [];

		// horizontal lines

		// loop through cells
		for (let y = 0; y < horizontalLinesData.length; y++) {
			for (let x = 0; x < horizontalLinesData[y].length; x++) {

				// loop through lines
				for (let lineIndex = 0; lineIndex < horizontalLinesData[y][x].length; lineIndex++) {
					let line = horizontalLinesData[y][x][lineIndex];

					// skip lines already marked as checked for possible combinations
					if (line.combinationsChecked) {
						continue;
					}

					// marks like as checked for combinations
					line.combinationsChecked = true;

					let combinedLine = new Line(Array.from(line.startPoint), Array.from(line.endPoint), Line.directions.horizontal, true);

					// loop through cells to the right
					for (let cellToRight = x + 1; cellToRight < horizontalLinesData[y].length; cellToRight++) {
						let matchFound = false;

						// loop through lines
						for (let lineToRightIndex = 0; lineToRightIndex < horizontalLinesData[y][cellToRight].length; lineToRightIndex++) {

							let lineToRight = horizontalLinesData[y][cellToRight][lineToRightIndex];

							// check if y positions match (x positions must fit if in cell to right)
							if (line.startPoint[1] == lineToRight.startPoint[1]) {
								combinedLine.endPoint[0] = lineToRight.endPoint[0];

								// marks line as checked for combinations
								lineToRight.combinationsChecked = true;

								// we can skip to the next cell now that we found a match
								matchFound = true;
								break;
							}
						}

						// if there aren't any matches in this cell, we can stop looking through cells on the right
						if (!matchFound) {
							cellToRight = horizontalLinesData[y].length;
							break;
						}
					}

					// save the new combined line we created
					combinedLinesData.push(combinedLine);
				}
			}
		}

		// vertical lines

		// loop through cells
		for (let y = 0; y < verticalLinesData.length; y++) {
			for (let x = 0; x < verticalLinesData[y].length; x++) {

				// loop through lines
				for (let lineIndex = 0; lineIndex < verticalLinesData[y][x].length; lineIndex++) {
					let line = verticalLinesData[y][x][lineIndex];

					// skip lines already marked as checked for possible combinations
					if (line.combinationsChecked) {
						continue;
					}

					// marks like as checked for combinations
					line.combinationsChecked = true;

					let combinedLine = new Line(Array.from(line.startPoint), Array.from(line.endPoint), Line.directions.vertical, true);

					// loop through cells below
					for (let cellBelow = y + 1; cellBelow < verticalLinesData.length; cellBelow++) {
						let matchFound = false;

						// loop through lines
						for (let lineBelowIndex = 0; lineBelowIndex < verticalLinesData[cellBelow][x].length; lineBelowIndex++) {

							let lineBelow = verticalLinesData[cellBelow][x][lineBelowIndex];

							// check if y positions match (x positions must fit if in cell to right)
							if (line.startPoint[0] == lineBelow.startPoint[0]) {
								combinedLine.endPoint[1] = lineBelow.endPoint[1];

								// marks line as checked for combinations
								lineBelow.combinationsChecked = true;

								// we can skip to the next cell now that we found a match
								matchFound = true;
								break;
							}
						}

						// if there aren't any matches in this cell, we can stop looking through cells on the right
						if (!matchFound) {
							cellBelow = verticalLinesData.length;
							break;
						}
					}

					// save the new combined line we created
					combinedLinesData.push(combinedLine);
				}
			}
		}
	}
	
</script>