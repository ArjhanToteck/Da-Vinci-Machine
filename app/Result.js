import CodeBlock from "@/src/components/CodeBlock";
import hljs from "highlight.js/lib/common";
import gcode from "highlight.js/lib/languages/gcode";
import { useEffect, useState } from "react";

// register gcode highlighting
hljs.registerLanguage("gcode", gcode);

export default function Result({ setPage, linesData, physicalDrawingSize, image, offset }) {
	const [linesGcode, setLinesGcode] = useState("");

	useEffect(() => {
		let newLinesGcode = "";

		const proportions = [
			physicalDrawingSize[0] / image.width,
			physicalDrawingSize[1] / image.height
		];

		let penPosition = [0, 0];

		for (let i = 0; i < linesData.length; i++) {
			const line = linesData[i];

			// scale to physical proportions
			line.startPoint[0] *= proportions[0];
			line.startPoint[1] *= proportions[1];
			line.endPoint[0] *= proportions[0];
			line.endPoint[1] *= proportions[1];

			// invert y axis on both points (convert from quadrant IV to quadrant I)
			line.startPoint[1] = physicalDrawingSize[1] - line.startPoint[1];
			line.endPoint[1] = physicalDrawingSize[1] - line.endPoint[1];

			// add offset to x and y
			line.startPoint[0] += offset[0];
			line.startPoint[1] += offset[1];
			line.endPoint[0] += offset[0];
			line.endPoint[1] += offset[1];

			// round to one decimal point
			line.startPoint[0] = line.startPoint[0].toFixed(1);
			line.startPoint[1] = line.startPoint[1].toFixed(1);
			line.endPoint[0] = line.endPoint[0].toFixed(1);
			line.endPoint[1] = line.endPoint[1].toFixed(1);

			// set to draw as the ox plows

			// check whether line.endPoint is closer to pen than line.startPoint (skip this the first time)
			if (i != 0 && pointDistance(penPosition, line.endPoint) < pointDistance(penPosition, line.startPoint)) {
				// flip line start and end to avoid unnecessary movement
				[line.startPoint, line.endPoint] = [line.endPoint, line.startPoint];
			}

			// actually draw line

			// lift pen (with z offset)
			newLinesGcode += `G0 Z${(5 + offset[2]).toFixed(1)}; lift pen\n`;

			// go to line start
			newLinesGcode += `G0 X${line.startPoint[0]} Y${line.startPoint[1]}; start line\n`;

			// lower pen (with z offset)
			newLinesGcode += `G0 Z${(0 + offset[2]).toFixed(1)}; lower pen\n`;

			// go to line end
			newLinesGcode += `G0 X${line.endPoint[0]} Y${line.endPoint[1]}; end line\n\n`;

			// remember pen position for next line
			penPosition = line.endPoint;
		}

		setLinesGcode(newLinesGcode);
	}, []);

	return (
		<section>
			<p>The resulting gcode file is ready. Download or copy it to use with your 3D printer.</p>

			<div>
				<CodeBlock showDownloadButton={true} maxCodeHeight="500px" language="gcode" fileName="image.gcode" code={
					`; generated by da vinci machine at ${new Date().toTimeString()}\n\n` +

					// initial settings
					"M104 S0 ; turn off nozzle heat\n" +
					"M140 S0 ; turn off bed heat\n" +
					"G21 ; set units to millimeters\n" +
					"G90 ; use absolute coordinates\n\n" +

					// initial home
					"G28 ; home all axes\n\n" +

					// draw lines
					linesGcode +

					// lift pen and go home
					`G0 Z${(5 + offset[2]).toFixed(1)}; lift pen\n` +
					"G28 ; home all axes\n"
				} />
			</div>

			<br />
			<button onClick={() => setPage("dimensions")}>Back</button>
			<br />
		</section >
	);
}

function pointDistance(point1, point2) {
	const x1 = point1[0];
	const y1 = point1[1];
	const x2 = point2[0];
	const y2 = point2[1];

	const distance = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
	return distance;
}